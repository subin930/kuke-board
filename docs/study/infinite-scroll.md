# 무한 스크롤 구현
## 📍페이지 번호 처리 방식의 쿼리를 그대로 사용하면 발생하는 문제점

데이터가 중복/누락될 가능성이 존재한다.

### 🅰️ 데이터가 중복되는 경우
사용자 A가 페이지 번호 방식으로 첫 번째 스크롤에서 3개의 게시글을 조회한다.
이때 사용자 B가 새로운 게시글을 작성하였고, 사용자 A가 이 시점에 스크롤을 내려서 두 번째 스크롤을 조회하는 상황이라면
4번째 게시물, 즉 새 게시물이 등록되기 전 3번째 게시물이 중복으로 조회되는 문제가 발생한다.

### 🅱️ 데이터가 누락되는 경우
사용자 A가 페이지 번호 방식으로 첫 번째 스크롤에서 3개의 게시글을 조회한다.
이때 사용자 B가 2번째 게시물을 삭제하였고, 사용자 A가 두 번째 스크롤을 조회하는 상황이라면
현 시점 3번째 게시물, 즉 삭제되기 이전 4번째 게시물이 조회에서 누락된다.

위와 같은 문제가 존재할 수 있기 때문에 새로운 로직이 필요하다.

## 📍로직

따라서 무한 스크롤을 구현할 때에는 **마지막으로 불러온 데이터를 기준점**으로 활용할 수 있다.

예를 들어 사용자 A가 첫 번째 스크롤을 조회하면, 클라이언트는 3개의 데이터를 받고 기준점 article_id = 5를 기억한다.

따라서 다음 요청 시에는 기준점인 5 미만의 데이터 중 3개를 불러오면 되는 것이다.

항상 기준점을 기준으로 쿼리를 수행하기 때문에 항상 로그 시간에 접근할 수 있다.

## 📍쿼리 구현

**1번 페이지**

```java
select *
from article
where board_id = :boardId
order by article_id desc
limit 30
```

**2번 페이지 이상**

```java
select *
from article
where board_id = :boardId and article_id < :last_article_id
order by article_id desc
limit 30
```